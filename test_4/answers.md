# Ответы на задание 4

<!-- Это мой первый опыт в декомпиляции и дизассемблировании,
     так что мог допустить грубые ошибки -->

## Ответы на вопросы

1. Если верить r2, то в rodata строка, которую мы хотим закодировать, выглядит следующим образом "DUfw". Выполнив `echo "DUfw" | xxd` получаем "44556677"
2. В файле `main.ghidra.prettyfied` вручную декомпилированная версия программы (улучшенный вывод ghidra). В рамках алгоритма создается строка, которую нужно закодировать в hex. В цикле мы читаем ее посимвольно, по одному байту (в программе тем не менее мы загружаем int, что не корректно на мой взгляд). Далее мы отделяем верхнюю часть и нижнюю часть этого байта, каждый по 4 бита, и используем их как индексы в специальной таблице перевода в 16-ричную систему счисления. В рамках программы она реализована как просто строка в rodata, которая содержит символы 0-9 и a-f. Потом вызывая стороннюю функцию мы по одному символу выводим 2 получившихся числа на экран. Затем выводим символ переноса строки и выходим из main
3. Программа написана в файле `test_4.c`. Сборка может быть осуществлена через Makefile
4. Следующие вещи кажутся мне не правильными в этой программе

    1. Цикл идет не до длины строки, а до 10. То есть после того, как он закодировал строку, он читает мусор в памяти
    2. При загрузке из памяти очередного символа используется мнемоника sw, а не sb, то есть загружается целый int. При запуске программы это по какой-то причине не вызывает проблем, но должно
    3. Могу ошибиться, но в main создается несколько переменных, которые затем нигде не применяются. Это -0x28(s0), -0x26(s0), -0x38(s0) и -0x40(s0). Однако возможно они используются в служебных целях
