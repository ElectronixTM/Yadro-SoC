# Ответы на задание 3

## Ответы на вопросы

1. Существует несколько вариантов исправить ошибку в данной програаме.

    1. Изменить макрос DEBUG_PRINT, чтобы он мог считаться statement после if. Добиться этого можно несколькими способами - заменой его на `{}`, заменой его на `0;` и подобными. Однако этот варинат я считаю плохим, потому что он не позволяте применять DEBUG_PRINT в тех контекстах, в которых можно применять printf
    2. Обрамить строчку после if в фигурные скобки, тогда компилятор поймет, что i++ идет после if, а не является частью его блока кода
    3. убрать у DEBUG_PRINT точку с запятой в самом конце и потребовать ставить ее явно. В таком случае можно применять макрос в тех же контекстах, что и printf. Только пожалуй следует еще обрамить его в скобочки `#define DEBUG_PRINT(x,y,z,i) (printf(x,y,z,i))`

2. Ошибка происходит из-за того, что если после if не открывается блок кода при помощи фигурных скобочек, он считает блоком своим блоком кода следующий statement. Когда включены отладочные print, этим statement становится поладочный printf, но когда они отключены, он заменяется на пустоту и уже не является statement'ом, поэтому в его качестве синтаксис языка захватывает `i++`. Теперь i инкрементируется только если условие верно, хотя нам необходимо, чтобы он инкрементировался на каждой итерации цикла

3. Система сборки утилитой make опирается на Makefile. В нем указываются цели, которые можно собрать при помощи make и их зависимости, а также последовательность команд, которая нужна для сборки этих целей. При сборке можно использовать переменные, которые затем подставляются вместо частей команды для достижения различных целей таких как возможность выбора компилятора и задания флагов компиляции, задания переменных компиляции, как в этом примере, и др. При вызове make можно передать параметры, один из них - `DBG_PRINT` используется для дальнейшего задания директивы препроцессора через `-D DBG_PRINT=1`, которая добавляется затем в CFLAGS - переменная, которая перенаправляется как флаги компилятора при сборке целей. Появится ли указанная директива в сборке определяется в блоке ifdef в начале Makefile'а, после определения некоторых других переменных

4. Разные типы переменных как отличаются между собой

    - Переменные make - те переменные, которые задаются в Makefile, используются для хранения значений, помогают избежать повторов, позволяют добиться единой точки для внесения изменений, без необходимости менять код во многих местах сразу. В данном примере они хранят информацию о названии выходного файла, исходниках, необходимых для его компиляции, флагах, передаваемых программам и названиях выходных файлов

    - Переменные окружения - это переменные, которые относятся в целом к состоянию вызывающей командной оболочки. Они определены на уровне системы и пользователь может их изменять и обновлять вне рамок компиляции. В таких переменных обычно хранится информация о конфигурации системы. В данном файле в них содержится информация о пути до кросс-компилятора и эмулятора

    - Под переменной компилятора могут подразумеваться несколько вещей. Во-первых это то, что мы передаем компилятору, чтобы определить его поведения. Это могут быть пути до библиотек, директорий с заголовочными файлами, опции оптимизации, флаги и флаги и опции для отдельных инструментов в тулчейне вроде линкера или ассемблера. Во-вторых могут иметься в виду переменные, задаваемые компилятором при сборке кода. Они обычно доступны через макросы вроде `__FILE__`, `__GNUC__`, `__LINUX__` и подобные. Они помогают разработчику поддерживать различный платформо-зависимый код. Например логика создания окон в Windows и Linux может отличаться, а использование ifdef позволяет сохранять единые интерфейсы и не повторяться.
